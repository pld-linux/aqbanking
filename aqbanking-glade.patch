--- aqbanking-1.6.2/src/frontends/g2banking/callbacks.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/callbacks.c	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,10 @@
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <gtk/gtk.h>
+
+#include "callbacks.h"
+#include "interface.h"
+#include "support.h"
+
--- aqbanking-1.6.2/src/frontends/g2banking/callbacks.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/callbacks.h	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,2 @@
+#include <gtk/gtk.h>
+
--- aqbanking-1.6.2/src/frontends/g2banking/interface.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/interface.c	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,397 @@
+/*
+ * DO NOT EDIT THIS FILE - it is generated by Glade.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+
+#include "callbacks.h"
+#include "interface.h"
+#include "support.h"
+
+#define GLADE_HOOKUP_OBJECT(component,widget,name) \
+  g_object_set_data_full (G_OBJECT (component), name, \
+    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
+
+#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
+  g_object_set_data (G_OBJECT (component), name, widget)
+
+GtkWidget*
+create_GConnectionDialog (void)
+{
+  GtkWidget *GConnectionDialog;
+  GtkWidget *dialog_vbox1;
+  GtkWidget *vbox1;
+  GtkWidget *vbox2;
+  GtkWidget *titleText;
+  GtkWidget *scrolledwindow1;
+  GtkWidget *logText;
+  GtkWidget *vbox3;
+  GtkWidget *table1;
+  GtkWidget *label3;
+  GtkWidget *progressBar;
+  GtkWidget *dialog_action_area1;
+  GtkWidget *closeButton;
+  GtkWidget *abortButton;
+
+  GConnectionDialog = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (GConnectionDialog), _("dialog1"));
+  gtk_window_set_type_hint (GTK_WINDOW (GConnectionDialog), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox1 = GTK_DIALOG (GConnectionDialog)->vbox;
+  gtk_widget_show (dialog_vbox1);
+
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
+
+  vbox2 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox2);
+  gtk_box_pack_start (GTK_BOX (vbox1), vbox2, TRUE, TRUE, 0);
+
+  titleText = gtk_label_new (_("--Text--"));
+  gtk_widget_show (titleText);
+  gtk_box_pack_start (GTK_BOX (vbox2), titleText, FALSE, TRUE, 0);
+  gtk_label_set_line_wrap (GTK_LABEL (titleText), TRUE);
+
+  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
+  gtk_widget_show (scrolledwindow1);
+  gtk_box_pack_start (GTK_BOX (vbox2), scrolledwindow1, TRUE, TRUE, 0);
+
+  logText = gtk_text_view_new ();
+  gtk_widget_show (logText);
+  gtk_container_add (GTK_CONTAINER (scrolledwindow1), logText);
+  gtk_text_buffer_set_text (gtk_text_view_get_buffer (GTK_TEXT_VIEW (logText)), _("test"), -1);
+
+  vbox3 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox3);
+  gtk_box_pack_start (GTK_BOX (vbox1), vbox3, FALSE, TRUE, 0);
+
+  table1 = gtk_table_new (1, 2, FALSE);
+  gtk_widget_show (table1);
+  gtk_box_pack_start (GTK_BOX (vbox3), table1, TRUE, TRUE, 0);
+
+  label3 = gtk_label_new (_("Progress"));
+  gtk_widget_show (label3);
+  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_SHRINK | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
+
+  progressBar = gtk_progress_bar_new ();
+  gtk_widget_show (progressBar);
+  gtk_table_attach (GTK_TABLE (table1), progressBar, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (GTK_SHRINK), 0, 0);
+
+  dialog_action_area1 = GTK_DIALOG (GConnectionDialog)->action_area;
+  gtk_widget_show (dialog_action_area1);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
+
+  closeButton = gtk_button_new_from_stock ("gtk-close");
+  gtk_widget_show (closeButton);
+  gtk_dialog_add_action_widget (GTK_DIALOG (GConnectionDialog), closeButton, GTK_RESPONSE_CLOSE);
+  GTK_WIDGET_SET_FLAGS (closeButton, GTK_CAN_DEFAULT);
+
+  abortButton = gtk_button_new_from_stock ("gtk-cancel");
+  gtk_widget_show (abortButton);
+  gtk_dialog_add_action_widget (GTK_DIALOG (GConnectionDialog), abortButton, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (abortButton, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (GConnectionDialog, GConnectionDialog, "GConnectionDialog");
+  GLADE_HOOKUP_OBJECT_NO_REF (GConnectionDialog, dialog_vbox1, "dialog_vbox1");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, vbox1, "vbox1");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, vbox2, "vbox2");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, titleText, "titleText");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, scrolledwindow1, "scrolledwindow1");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, logText, "logText");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, vbox3, "vbox3");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, table1, "table1");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, label3, "label3");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, progressBar, "progressBar");
+  GLADE_HOOKUP_OBJECT_NO_REF (GConnectionDialog, dialog_action_area1, "dialog_action_area1");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, closeButton, "closeButton");
+  GLADE_HOOKUP_OBJECT (GConnectionDialog, abortButton, "abortButton");
+
+  return GConnectionDialog;
+}
+
+GtkWidget*
+create_GSimpleBox (void)
+{
+  GtkWidget *GSimpleBox;
+  GtkWidget *textLabel;
+
+  GSimpleBox = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_window_set_title (GTK_WINDOW (GSimpleBox), _("Message"));
+  gtk_window_set_position (GTK_WINDOW (GSimpleBox), GTK_WIN_POS_CENTER_ON_PARENT);
+
+  textLabel = gtk_label_new (_("label4"));
+  gtk_widget_show (textLabel);
+  gtk_container_add (GTK_CONTAINER (GSimpleBox), textLabel);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (GSimpleBox, GSimpleBox, "GSimpleBox");
+  GLADE_HOOKUP_OBJECT (GSimpleBox, textLabel, "textLabel");
+
+  return GSimpleBox;
+}
+
+GtkWidget*
+create_GJobView (void)
+{
+  GtkWidget *GJobView;
+  GtkWidget *hbox1;
+  GtkWidget *scrolledwindow2;
+  GtkWidget *jobListView;
+  GtkWidget *vbuttonbox1;
+  GtkWidget *dequeueButton;
+  GtkWidget *alignment2;
+  GtkWidget *hbox3;
+  GtkWidget *image2;
+  GtkWidget *label5;
+  GtkWidget *execButton;
+  GtkWidget *alignment1;
+  GtkWidget *hbox2;
+  GtkWidget *image1;
+  GtkWidget *label4;
+
+  GJobView = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_window_set_title (GTK_WINDOW (GJobView), _("Outbox"));
+  gtk_window_set_destroy_with_parent (GTK_WINDOW (GJobView), TRUE);
+
+  hbox1 = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (hbox1);
+  gtk_container_add (GTK_CONTAINER (GJobView), hbox1);
+
+  scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
+  gtk_widget_show (scrolledwindow2);
+  gtk_box_pack_start (GTK_BOX (hbox1), scrolledwindow2, TRUE, TRUE, 0);
+
+  jobListView = gtk_tree_view_new ();
+  gtk_widget_show (jobListView);
+  gtk_container_add (GTK_CONTAINER (scrolledwindow2), jobListView);
+  gtk_tree_view_set_reorderable (GTK_TREE_VIEW (jobListView), TRUE);
+
+  vbuttonbox1 = gtk_vbutton_box_new ();
+  gtk_widget_show (vbuttonbox1);
+  gtk_box_pack_start (GTK_BOX (hbox1), vbuttonbox1, FALSE, FALSE, 0);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (vbuttonbox1), GTK_BUTTONBOX_START);
+
+  dequeueButton = gtk_button_new ();
+  gtk_widget_show (dequeueButton);
+  gtk_container_add (GTK_CONTAINER (vbuttonbox1), dequeueButton);
+  GTK_WIDGET_SET_FLAGS (dequeueButton, GTK_CAN_DEFAULT);
+
+  alignment2 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment2);
+  gtk_container_add (GTK_CONTAINER (dequeueButton), alignment2);
+
+  hbox3 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox3);
+  gtk_container_add (GTK_CONTAINER (alignment2), hbox3);
+
+  image2 = gtk_image_new_from_stock ("gtk-delete", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image2);
+  gtk_box_pack_start (GTK_BOX (hbox3), image2, FALSE, FALSE, 0);
+
+  label5 = gtk_label_new_with_mnemonic (_("Dequeue"));
+  gtk_widget_show (label5);
+  gtk_box_pack_start (GTK_BOX (hbox3), label5, FALSE, FALSE, 0);
+
+  execButton = gtk_button_new ();
+  gtk_widget_show (execButton);
+  gtk_container_add (GTK_CONTAINER (vbuttonbox1), execButton);
+  GTK_WIDGET_SET_FLAGS (execButton, GTK_CAN_DEFAULT);
+
+  alignment1 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment1);
+  gtk_container_add (GTK_CONTAINER (execButton), alignment1);
+
+  hbox2 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox2);
+  gtk_container_add (GTK_CONTAINER (alignment1), hbox2);
+
+  image1 = gtk_image_new_from_stock ("gtk-execute", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image1);
+  gtk_box_pack_start (GTK_BOX (hbox2), image1, FALSE, FALSE, 0);
+
+  label4 = gtk_label_new_with_mnemonic (_("Execute"));
+  gtk_widget_show (label4);
+  gtk_box_pack_start (GTK_BOX (hbox2), label4, FALSE, FALSE, 0);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (GJobView, GJobView, "GJobView");
+  GLADE_HOOKUP_OBJECT (GJobView, hbox1, "hbox1");
+  GLADE_HOOKUP_OBJECT (GJobView, scrolledwindow2, "scrolledwindow2");
+  GLADE_HOOKUP_OBJECT (GJobView, jobListView, "jobListView");
+  GLADE_HOOKUP_OBJECT (GJobView, vbuttonbox1, "vbuttonbox1");
+  GLADE_HOOKUP_OBJECT (GJobView, dequeueButton, "dequeueButton");
+  GLADE_HOOKUP_OBJECT (GJobView, alignment2, "alignment2");
+  GLADE_HOOKUP_OBJECT (GJobView, hbox3, "hbox3");
+  GLADE_HOOKUP_OBJECT (GJobView, image2, "image2");
+  GLADE_HOOKUP_OBJECT (GJobView, label5, "label5");
+  GLADE_HOOKUP_OBJECT (GJobView, execButton, "execButton");
+  GLADE_HOOKUP_OBJECT (GJobView, alignment1, "alignment1");
+  GLADE_HOOKUP_OBJECT (GJobView, hbox2, "hbox2");
+  GLADE_HOOKUP_OBJECT (GJobView, image1, "image1");
+  GLADE_HOOKUP_OBJECT (GJobView, label4, "label4");
+
+  return GJobView;
+}
+
+GtkWidget*
+create_GInputBox (void)
+{
+  GtkWidget *GInputBox;
+  GtkWidget *dialog_vbox2;
+  GtkWidget *vbox5;
+  GtkWidget *textLabel;
+  GtkWidget *table3;
+  GtkWidget *label9;
+  GtkWidget *confirmLabel;
+  GtkWidget *inputEntry;
+  GtkWidget *confirmEntry;
+  GtkWidget *dialog_action_area2;
+  GtkWidget *abortbutton;
+  GtkWidget *okButton;
+
+  GInputBox = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (GInputBox), _("Input"));
+  gtk_window_set_modal (GTK_WINDOW (GInputBox), TRUE);
+  gtk_window_set_type_hint (GTK_WINDOW (GInputBox), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox2 = GTK_DIALOG (GInputBox)->vbox;
+  gtk_widget_show (dialog_vbox2);
+
+  vbox5 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox5);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox2), vbox5, TRUE, TRUE, 0);
+
+  textLabel = gtk_label_new (_("label8"));
+  gtk_widget_show (textLabel);
+  gtk_box_pack_start (GTK_BOX (vbox5), textLabel, TRUE, TRUE, 0);
+
+  table3 = gtk_table_new (2, 2, FALSE);
+  gtk_widget_show (table3);
+  gtk_box_pack_start (GTK_BOX (vbox5), table3, FALSE, FALSE, 0);
+
+  label9 = gtk_label_new (_("Input"));
+  gtk_widget_show (label9);
+  gtk_table_attach (GTK_TABLE (table3), label9, 0, 1, 0, 1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (label9), 0, 0.5);
+
+  confirmLabel = gtk_label_new (_("Confirm"));
+  gtk_table_attach (GTK_TABLE (table3), confirmLabel, 0, 1, 1, 2,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  gtk_misc_set_alignment (GTK_MISC (confirmLabel), 0, 0.5);
+
+  inputEntry = gtk_entry_new ();
+  gtk_widget_show (inputEntry);
+  gtk_table_attach (GTK_TABLE (table3), inputEntry, 1, 2, 0, 1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  confirmEntry = gtk_entry_new ();
+  gtk_table_attach (GTK_TABLE (table3), confirmEntry, 1, 2, 1, 2,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+
+  dialog_action_area2 = GTK_DIALOG (GInputBox)->action_area;
+  gtk_widget_show (dialog_action_area2);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area2), GTK_BUTTONBOX_END);
+
+  abortbutton = gtk_button_new_from_stock ("gtk-cancel");
+  gtk_widget_show (abortbutton);
+  gtk_dialog_add_action_widget (GTK_DIALOG (GInputBox), abortbutton, GTK_RESPONSE_CANCEL);
+  GTK_WIDGET_SET_FLAGS (abortbutton, GTK_CAN_DEFAULT);
+
+  okButton = gtk_button_new_from_stock ("gtk-ok");
+  gtk_widget_show (okButton);
+  gtk_dialog_add_action_widget (GTK_DIALOG (GInputBox), okButton, GTK_RESPONSE_OK);
+  GTK_WIDGET_SET_FLAGS (okButton, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (GInputBox, GInputBox, "GInputBox");
+  GLADE_HOOKUP_OBJECT_NO_REF (GInputBox, dialog_vbox2, "dialog_vbox2");
+  GLADE_HOOKUP_OBJECT (GInputBox, vbox5, "vbox5");
+  GLADE_HOOKUP_OBJECT (GInputBox, textLabel, "textLabel");
+  GLADE_HOOKUP_OBJECT (GInputBox, table3, "table3");
+  GLADE_HOOKUP_OBJECT (GInputBox, label9, "label9");
+  GLADE_HOOKUP_OBJECT (GInputBox, confirmLabel, "confirmLabel");
+  GLADE_HOOKUP_OBJECT (GInputBox, inputEntry, "inputEntry");
+  GLADE_HOOKUP_OBJECT (GInputBox, confirmEntry, "confirmEntry");
+  GLADE_HOOKUP_OBJECT_NO_REF (GInputBox, dialog_action_area2, "dialog_action_area2");
+  GLADE_HOOKUP_OBJECT (GInputBox, abortbutton, "abortbutton");
+  GLADE_HOOKUP_OBJECT (GInputBox, okButton, "okButton");
+
+  return GInputBox;
+}
+
+GtkWidget*
+create_GMessageBox (void)
+{
+  GtkWidget *GMessageBox;
+  GtkWidget *dialog_vbox3;
+  GtkWidget *textLabel;
+  GtkWidget *dialog_action_area3;
+  GtkWidget *button1;
+  GtkWidget *button2;
+  GtkWidget *button3;
+
+  GMessageBox = gtk_dialog_new ();
+  gtk_window_set_title (GTK_WINDOW (GMessageBox), _("Message"));
+  gtk_window_set_modal (GTK_WINDOW (GMessageBox), TRUE);
+  gtk_window_set_destroy_with_parent (GTK_WINDOW (GMessageBox), TRUE);
+  gtk_window_set_type_hint (GTK_WINDOW (GMessageBox), GDK_WINDOW_TYPE_HINT_DIALOG);
+
+  dialog_vbox3 = GTK_DIALOG (GMessageBox)->vbox;
+  gtk_widget_show (dialog_vbox3);
+
+  textLabel = gtk_label_new (_("label10"));
+  gtk_widget_show (textLabel);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox3), textLabel, TRUE, TRUE, 0);
+
+  dialog_action_area3 = GTK_DIALOG (GMessageBox)->action_area;
+  gtk_widget_show (dialog_action_area3);
+  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area3), GTK_BUTTONBOX_END);
+
+  button1 = gtk_button_new_with_mnemonic (_("button1"));
+  gtk_widget_show (button1);
+  gtk_dialog_add_action_widget (GTK_DIALOG (GMessageBox), button1, 0);
+  GTK_WIDGET_SET_FLAGS (button1, GTK_CAN_DEFAULT);
+
+  button2 = gtk_button_new_with_mnemonic (_("button2"));
+  gtk_dialog_add_action_widget (GTK_DIALOG (GMessageBox), button2, 0);
+  GTK_WIDGET_SET_FLAGS (button2, GTK_CAN_DEFAULT);
+
+  button3 = gtk_button_new_with_mnemonic (_("button3"));
+  gtk_dialog_add_action_widget (GTK_DIALOG (GMessageBox), button3, 0);
+  GTK_WIDGET_SET_FLAGS (button3, GTK_CAN_DEFAULT);
+
+  /* Store pointers to all widgets, for use by lookup_widget(). */
+  GLADE_HOOKUP_OBJECT_NO_REF (GMessageBox, GMessageBox, "GMessageBox");
+  GLADE_HOOKUP_OBJECT_NO_REF (GMessageBox, dialog_vbox3, "dialog_vbox3");
+  GLADE_HOOKUP_OBJECT (GMessageBox, textLabel, "textLabel");
+  GLADE_HOOKUP_OBJECT_NO_REF (GMessageBox, dialog_action_area3, "dialog_action_area3");
+  GLADE_HOOKUP_OBJECT (GMessageBox, button1, "button1");
+  GLADE_HOOKUP_OBJECT (GMessageBox, button2, "button2");
+  GLADE_HOOKUP_OBJECT (GMessageBox, button3, "button3");
+
+  return GMessageBox;
+}
+
--- aqbanking-1.6.2/src/frontends/g2banking/interface.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/interface.h	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,9 @@
+/*
+ * DO NOT EDIT THIS FILE - it is generated by Glade.
+ */
+
+GtkWidget* create_GConnectionDialog (void);
+GtkWidget* create_GSimpleBox (void);
+GtkWidget* create_GJobView (void);
+GtkWidget* create_GInputBox (void);
+GtkWidget* create_GMessageBox (void);
--- aqbanking-1.6.2/src/frontends/g2banking/support.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/support.c	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,144 @@
+/*
+ * DO NOT EDIT THIS FILE - it is generated by Glade.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+#include <gtk/gtk.h>
+
+#include "support.h"
+
+GtkWidget*
+lookup_widget                          (GtkWidget       *widget,
+                                        const gchar     *widget_name)
+{
+  GtkWidget *parent, *found_widget;
+
+  for (;;)
+    {
+      if (GTK_IS_MENU (widget))
+        parent = gtk_menu_get_attach_widget (GTK_MENU (widget));
+      else
+        parent = widget->parent;
+      if (!parent)
+        parent = (GtkWidget*) g_object_get_data (G_OBJECT (widget), "GladeParentKey");
+      if (parent == NULL)
+        break;
+      widget = parent;
+    }
+
+  found_widget = (GtkWidget*) g_object_get_data (G_OBJECT (widget),
+                                                 widget_name);
+  if (!found_widget)
+    g_warning ("Widget not found: %s", widget_name);
+  return found_widget;
+}
+
+static GList *pixmaps_directories = NULL;
+
+/* Use this function to set the directory containing installed pixmaps. */
+void
+add_pixmap_directory                   (const gchar     *directory)
+{
+  pixmaps_directories = g_list_prepend (pixmaps_directories,
+                                        g_strdup (directory));
+}
+
+/* This is an internally used function to find pixmap files. */
+static gchar*
+find_pixmap_file                       (const gchar     *filename)
+{
+  GList *elem;
+
+  /* We step through each of the pixmaps directory to find it. */
+  elem = pixmaps_directories;
+  while (elem)
+    {
+      gchar *pathname = g_strdup_printf ("%s%s%s", (gchar*)elem->data,
+                                         G_DIR_SEPARATOR_S, filename);
+      if (g_file_test (pathname, G_FILE_TEST_EXISTS))
+        return pathname;
+      g_free (pathname);
+      elem = elem->next;
+    }
+  return NULL;
+}
+
+/* This is an internally used function to create pixmaps. */
+GtkWidget*
+create_pixmap                          (GtkWidget       *widget,
+                                        const gchar     *filename)
+{
+  gchar *pathname = NULL;
+  GtkWidget *pixmap;
+
+  if (!filename || !filename[0])
+      return gtk_image_new ();
+
+  pathname = find_pixmap_file (filename);
+
+  if (!pathname)
+    {
+      g_warning (_("Couldn't find pixmap file: %s"), filename);
+      return gtk_image_new ();
+    }
+
+  pixmap = gtk_image_new_from_file (pathname);
+  g_free (pathname);
+  return pixmap;
+}
+
+/* This is an internally used function to create pixmaps. */
+GdkPixbuf*
+create_pixbuf                          (const gchar     *filename)
+{
+  gchar *pathname = NULL;
+  GdkPixbuf *pixbuf;
+  GError *error = NULL;
+
+  if (!filename || !filename[0])
+      return NULL;
+
+  pathname = find_pixmap_file (filename);
+
+  if (!pathname)
+    {
+      g_warning (_("Couldn't find pixmap file: %s"), filename);
+      return NULL;
+    }
+
+  pixbuf = gdk_pixbuf_new_from_file (pathname, &error);
+  if (!pixbuf)
+    {
+      fprintf (stderr, "Failed to load pixbuf file: %s: %s\n",
+               pathname, error->message);
+      g_error_free (error);
+    }
+  g_free (pathname);
+  return pixbuf;
+}
+
+/* This is used to set ATK action descriptions. */
+void
+glade_set_atk_action_description       (AtkAction       *action,
+                                        const gchar     *action_name,
+                                        const gchar     *description)
+{
+  gint n_actions, i;
+
+  n_actions = atk_action_get_n_actions (action);
+  for (i = 0; i < n_actions; i++)
+    {
+      if (!strcmp (atk_action_get_name (action, i), action_name))
+        atk_action_set_description (action, i, description);
+    }
+}
+
--- aqbanking-1.6.2/src/frontends/g2banking/support.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ aqbanking-1.6.2/src/frontends/g2banking/support.h	2006-01-15 17:27:07.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+ * DO NOT EDIT THIS FILE - it is generated by Glade.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <gtk/gtk.h>
+
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (PACKAGE, String)
+#  define Q_(String) g_strip_context ((String), gettext (String))
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define Q_(String) g_strip_context ((String), (String))
+#  define N_(String) (String)
+#endif
+
+
+/*
+ * Public Functions.
+ */
+
+/*
+ * This function returns a widget in a component created by Glade.
+ * Call it with the toplevel widget in the component (i.e. a window/dialog),
+ * or alternatively any widget in the component, and the name of the widget
+ * you want returned.
+ */
+GtkWidget*  lookup_widget              (GtkWidget       *widget,
+                                        const gchar     *widget_name);
+
+
+/* Use this function to set the directory containing installed pixmaps. */
+void        add_pixmap_directory       (const gchar     *directory);
+
+
+/*
+ * Private Functions.
+ */
+
+/* This is used to create the pixmaps used in the interface. */
+GtkWidget*  create_pixmap              (GtkWidget       *widget,
+                                        const gchar     *filename);
+
+/* This is used to create the pixbufs used in the interface. */
+GdkPixbuf*  create_pixbuf              (const gchar     *filename);
+
+/* This is used to set ATK action descriptions. */
+void        glade_set_atk_action_description (AtkAction       *action,
+                                              const gchar     *action_name,
+                                              const gchar     *description);
+
